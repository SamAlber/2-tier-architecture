# AWS Account Information
data "aws_caller_identity" "current" {}

data "aws_availability_zones" "available" {
  state = "available"
}

# ------------------------- VPC ------------------------- #

# VPC
resource "aws_vpc" "main" {
  cidr_block           = var.vpc_cidr
  enable_dns_support   = true
  enable_dns_hostnames = true
  tags = {
    Name = "two-tier-vpc"
  }
}

# ------------------------- Subnets ------------------------- #


# Public Subnets
resource "aws_subnet" "public" {
  count      = length(var.public_subnet_cidrs)
  vpc_id     = aws_vpc.main.id
  cidr_block = var.public_subnet_cidrs[count.index]
  // count.index dynamically selects the CIDR block for the current iteration (e.g., 10.0.1.0/24 for the first subnet, 10.0.2.0/24 for the second).
  // When Terraform loops (via the count parameter) to create multiple subnets, it assigns a different CIDR block from the list for each subnet. 
  map_public_ip_on_launch = true
  availability_zone       = data.aws_availability_zones.available.names[count.index]
  /* data.aws_availability_zones.available retrieves all available AZs in the region.
    .names returns a list of AZ names (e.g., ["us-east-1a", "us-east-1b", "us-east-1c"]).
     count.index selects the AZ corresponding to the current iteration.
  */
  tags = {
    Name = "public-subnet-${count.index + 1}" // count starts from 0 but we will increment 1 to make it understandable  
  }
}

# Private Subnets
resource "aws_subnet" "private" {
  count             = length(var.private_subnet_cidrs)
  vpc_id            = aws_vpc.main.id
  cidr_block        = var.private_subnet_cidrs[count.index]
  availability_zone = data.aws_availability_zones.available.names[count.index]
  tags = {
    Name = "private-subnet-${count.index + 1}" // count starts from 0 but we will increment 1 to make it understandable 
  }
}

# ------------------------- IGW ------------------------- #


# Internet Gateway                           // The public route table will allow internet access for public subnets via the IGW. 
resource "aws_internet_gateway" "igw" {
  vpc_id = aws_vpc.main.id
  tags = {
    Name = "two-tier-igw"
  }
}

# ------------------------- Route Tables ------------------------- #


# Public Route Table
resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id                   // links the route table to the VPC. 
  route {                                    // Adds a route to the route table. 
    cidr_block = "0.0.0.0/0"                 // Specifies that this route applies to all IP addresses. (This enables internet access.)
    gateway_id = aws_internet_gateway.igw.id // Points to the Internet Gateway (IGW) as the next hop for traffic going to external addresses.
  }
  tags = {
    Name = "public-route-table"
  }
} // Allows instances in public subnets to send/receive traffic to/from the internet. 

# Associate Route Table with Public Subnets
resource "aws_route_table_association" "public" {
  count          = length(var.public_subnet_cidrs)   // Dynamically creates as many associations as there are public subnets. 
  subnet_id      = aws_subnet.public[count.index].id // Selects each public subnet created earlier. 
  route_table_id = aws_route_table.public.id         // Links the public route table to the selected subnet. 
}                                                    // All public subnets use the same public route table to access the internet via the Internet Gateway.

# ------------------------- Security Groups ------------------------- #
#    |
#    v
# ------------------------- Web Layer Security Group ------------------------- #

# Web Layer Security Group, Ensures the web servers can send any outbound traffic (e.g., to external APIs or services).
/*
Controls inbound and outbound traffic for the EC2 instances hosting the application (web servers).
Allows HTTP and HTTPS traffic from anywhere (e.g., public internet) to the web layer.
Ensures the web servers can send any outbound traffic (e.g., to external APIs or services).

*/
resource "aws_security_group" "web_sg" { // followed by a random suffix generated by Terraform. 
  name   = "web-sg"
  vpc_id = aws_vpc.main.id

  # Allow HTTP from anywhere
  ingress {
    from_port   = var.http_port
    to_port     = var.http_port
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  # Allow HTTPS from anywhere
  ingress {
    from_port   = var.https_port
    to_port     = var.https_port
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  // For SSH access
  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"                 // For SSH access to EC2 instances 
    cidr_blocks = ["46.120.152.174/32"] # found using curl http://checkip.amazonaws.com // <your-ip-address>/32 restricts access to a single IP (your current public IP).  
  }

  # Allow all outbound traffic
  egress {
    from_port   = 0             // A wildcard range, allowing traffic on any port. 
    to_port     = 0             // A wildcard range, allowing traffic on any port.
    protocol    = "-1"          //  Allows all protocols (TCP, UDP, ICMP, etc.). 
    cidr_blocks = ["0.0.0.0/0"] // <your-ip-address>/32 restricts access to a single IP (your current public IP). 
  }

  tags = {
    Name = "Web Layer Security Group"
  }
}

# ------------------------- Database Layer Security Group ------------------------- #

/*
Controls traffic for the database (e.g., RDS).
Allows only traffic from the web servers in the web_sg to access the database on the specified database port (e.g., MySQL on port 3306).
Ensures the database can send outbound traffic if needed (e.g., to update itself or connect to other AWS services).
*/

# Database Layer Security Group
resource "aws_security_group" "db_sg" {
  name   = "db-sg" // no name_prefix = db-sg- because it will redeploy the instances each time. same for web_sg security group (still doesn't work btw)
  vpc_id = aws_vpc.main.id

  # Allow database traffic from the web security group
  ingress {
    from_port       = var.db_port
    to_port         = var.db_port // Specify the port range (e.g., var.db_port = 3306 for MySQL). 
    protocol        = "tcp"
    security_groups = [aws_security_group.web_sg.id] // Instead of using cidr_blocks, this references the web_sg security group. This ensures only instances in the web security group can access the database.
  }

  # Allow all outbound traffic, This is useful for things like backups to S3, sending metrics, or updates. 
  egress {
    from_port   = 0    // A wildcard range, allowing traffic on any port. 
    to_port     = 0    // A wildcard range, allowing traffic on any port.  
    protocol    = "-1" //  Allows all protocols (TCP, UDP, ICMP, etc.). 
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "Database Layer Security Group"
  }
}

# ------------------------- EC2 Module ------------------------- #

// Allows an IAM Role to be attached to an EC2 instance, enabling the instance to assume the role and gain permissions specified by the IAM policies associated with the role. 
resource "aws_iam_instance_profile" "ec2_instance_profile" {
  name = "ec2-ssm-instance-profile"
  role = aws_iam_role.ec2_ssm_role.name
}
/*
# EC2 does not directly use IAM roles. Instead, it uses an IAM Instance Profile, which serves as a wrapper around the role to attach it to the EC2 instance.!!!
AWS explicitly requires an Instance Profile to attach an IAM role to an EC2 instance.
If you only create an IAM role without the instance profile, Terraform or the AWS Console won’t allow you to attach it to the EC2 instance.
*/

module "ec2" {
  source           = "./modules/ec2"
  instance_profile = aws_iam_instance_profile.ec2_instance_profile.name
  instance_count   = 2
  ami              = "ami-0c02fb55956c7d316" // This is the ID for an Amazon Linux 2 AMI in the AWS region!!! you’re working in. (Go to EC2 > AMIs. to find it out)
  instance_type    = "t2.micro"
  subnet_ids       = aws_subnet.public[*].id
  key_name         = aws_key_pair.web_key.key_name // Specifies the name of the SSH key pair used to access the EC2 instances. The key pair allows secure remote access to the instances (via SSH).
  // When you try to SSH into an EC2 instance, AWS uses the public key associated with the key pair to verify your private key. The resource below creates a key if it hasn't been created it and imports into EC2 key pairs in AWS.
  security_groups = [aws_security_group.web_sg.id]
  name_prefix     = "web-server"
  tags = {
    Environment = "Dev"
  }
}

# Creates the key to connect to the AWS EC2 instance after we created it using: ssh-keygen -t rsa -b 2048 -f ~/.ssh/id_rsa -N ""
resource "aws_key_pair" "web_key" {
  key_name   = "web-server-key"
  public_key = file("~/.ssh/id_rsa.pub")
}

// We will then access the EC2 using: ssh -i ~/.ssh/id_rsa ec2-user@3.23.45.67 (find the address using terraform console) (ec2-user for Amazon Linux 2, Amazon Linux, or RHEL-based AMIs).

### SUPER IMPORTANT, ALB NEEDS A TARGET GROUP ATTACHED TO IT! 
resource "aws_lb_target_group_attachment" "ec2_targets" {
  count            = length(module.ec2.instance_ids)      # Reference EC2 instance IDs from the EC2 module (Dynamically creates one aws_lb_target_group_attachment for each EC2 instance.)
  target_group_arn = module.alb.target_group_arn          # Reference ALB's target group ARN (Without this, the ALB won’t know which backend instances to route traffic to, The target group is where the ALB forwards incoming traffic.)
  target_id        = module.ec2.instance_ids[count.index] # Reference instance IDs from the EC2 module (Ensures every instance gets attached to the target group individually.)
  port             = 80                                   # Target group port
}

/*
ec2.instance.ids and not aws_instance.this? 
You cannot directly reference aws_instance.this in the root module because the EC2 instances are defined inside a child module. Terraform enforces this separation to maintain modularity.

If you try to reference aws_instance.this directly in the root module, Terraform will throw an error because aws_instance.this is not defined in the root module—it exists only inside the ec2 module.
|
v
When working with modules, you don’t directly access the resources (aws_instance.this) inside the module. Instead, you rely on outputs declared in the module.

Quick Analogy
Think of Terraform modules like functions in programming:

Inputs are like function arguments (variables passed to the module).
Outputs are like return values (data exposed by the module).
You wouldn’t expect to access a local variable inside a function from outside the function, right? The same logic applies to Terraform modules.
*/

/*
port = 80
What It Does:

Specifies the port the target group uses to send traffic to the EC2 instances.
This must match the port your application (NGINX) is listening on.
Why It’s Needed:

Ensures traffic is routed correctly to the backend application.
*/



# ------------------------- ALB Module ------------------------- #

module "alb" {
  source          = "./modules/alb"
  name            = "app-load-balancer"
  internal        = false                          // Specifies whether the ALB is internet-facing or internal (false: The ALB is public and accessible over the internet. / true: The ALB is private and accessible only within the VPC.)
  security_groups = [aws_security_group.web_sg.id] # Associates the ALB with a security group. The ALB will inherit the rules defined in the web_sg security group, such as allowing HTTP and HTTPS traffic.
  subnets         = aws_subnet.public[*].id        # Specifies the subnets where the ALB will be deployed. This uses all public subnets created earlier (aws_subnet.public), and [*].id selects the id of each subnet in the list. 
  tags = {
    Environment = "Dev"
  }
  target_group_name     = "web-target-group" // Specifies the name of the target group where the ALB will route traffic.
  target_group_port     = 80                 // Defines the port on the target group that the ALB will use to forward traffic (e.g., port 80 for HTTP). 
  target_group_protocol = "HTTP"             // Specifies the protocol for communication between the ALB and the target group (e.g., HTTP or HTTPS). 
  vpc_id                = aws_vpc.main.id    // Links the ALB and its target group to the VPC (aws_vpc.main). 
  health_check_path     = "/"                // Defines the endpoint for health checks. The ALB will regularly ping / on each target (EC2 instance) to ensure it’s healthy.
  listener_port         = 80                 // Sp // Specifies the protocol the ALB uses to accept traffic.
  listener_protocol     = "HTTP"
}

# RDS require a subnet group to operate (private subnets for security)! 
resource "aws_db_subnet_group" "db_subnet_group" {
  name       = "rds-subnet-group"
  subnet_ids = aws_subnet.private[*].id

  tags = {
    Name = "RDS Subnet Group"
  }
}

/*
Why RDS Should Be in Private Subnets
No Need for Public Internet Access:

RDS instances typically only need to be accessed by application servers (EC2 instances) or other internal AWS services.
Placing RDS in private subnets restricts internet exposure, reducing the attack surface.
Best Practices for Security:

AWS recommends placing databases in private subnets to prevent direct access from the internet.
This ensures that only resources within your VPC (e.g., EC2, Lambda) can communicate with the database.
Network Control:

By placing RDS in private subnets, you can enforce stricter access controls via:
Security groups.
Network ACLs.
Routing rules.
*/

module "rds" {
  source                = "./modules/rds"
  allocated_storage     = 20
  max_allocated_storage = 100
  engine                = "mysql"
  engine_version        = "8.0.40"       // taken from the documentation 
  instance_class        = "db.m8g.large" // found in documentation
  db_name               = "webappdb"
  db_username           = data.aws_ssm_parameter.db_username.value
  db_password           = data.aws_ssm_parameter.db_password.value
  parameter_group_name  = "default.mysql8.0" // AWS does not create a specific parameter group for minor versions (e.g., mysql8.4.3).
  publicly_accessible   = false
  skip_final_snapshot   = true
  multi_az              = true
  db_security_group_id  = aws_security_group.db_sg.id
  db_subnet_group_name  = aws_db_subnet_group.db_subnet_group.name

  tags = {
    Name        = "WebAppDB"
    Environment = "dev"
  }
}

// Fetches parameters for RDS that we added manually
data "aws_ssm_parameter" "db_username" {
  name            = "db_username"
  with_decryption = true
}

data "aws_ssm_parameter" "db_password" {
  name            = "db_password"
  with_decryption = true
}

# ------------------------- NAT Gateway ------------------------- #

# The Elastic IP (EIP) resource is necessary for the NAT Gateway because it requires a static, public IP address to enable outbound internet access for resources in private subnets.
# A NAT Gateway allows instances in private subnets to connect to the internet.
# To route this outbound traffic, the NAT Gateway needs a public-facing IP address that is routable on the internet.
# Route outbound traffic through the NAT Gateway, leveraging the EIP for internet connectivity.
# Elastic IPs are static, ensuring that your NAT Gateway's external IP address does not change. 
resource "aws_eip" "nat" {
  count  = length(var.private_subnet_cidrs) # IMPORTANT! BASED ON NUMBER OF PRIVATE SUBNETS! 
  domain = "vpc"

  tags = {
    Name = "NAT Gateway EIP ${count.index + 1}"
  }
}

# One NAT Gateway per public subnet for high availability. 
resource "aws_nat_gateway" "nat" {
  count         = length(var.private_subnet_cidrs)
  allocation_id = aws_eip.nat[count.index].id
  subnet_id     = aws_subnet.public[count.index].id # IMPORTANT! A NAT GATEWAY IS PLACED IN A PUBLIC SUBNET (THE RESOURCE WILL CALL THE NAT IN THE PUBLIC SUBNET IN THE SAME AZ FIRST)

  tags = {
    Name = "NAT Gateway ${count.index + 1}"
  }
}

# Creating a private route table for each NAT Gateway
resource "aws_route_table" "private" {
  count  = length(var.private_subnet_cidrs)
  vpc_id = aws_vpc.main.id

  route {
    cidr_block     = "0.0.0.0/0" # It essentially says, "This route applies to any destination." 
    nat_gateway_id = aws_nat_gateway.nat[count.index].id
  }
  /*
  "0.0.0.0/0" When defined in a route table, it acts as a default route, meaning:
  Any traffic not explicitly defined by another route in the table will be directed through this route.

  Why Use It Here?
  Private Subnet Traffic
  Outbound Traffic:

  Private subnets need to send traffic to the internet (e.g., for updates, API calls).
  Since private subnets don't have direct access to the internet, they route outbound traffic through the NAT Gateway.
  Route Definition:

  cidr_block = "0.0.0.0/0" ensures all outbound traffic from the private subnets, regardless of the destination, is sent to the NAT Gateway.
  NAT Gateway Role:
  The nat_gateway_id in the same route specifies the NAT Gateway as the next hop for the default route.
  The NAT Gateway handles sending this traffic to the internet and returning responses back to the private subnet.

  Without the default route (0.0.0.0/0) pointing to the NAT Gateway, private subnets cannot send traffic to the internet.
  For example, instances in private subnets wouldn’t be able to:
  Download software updates.
  Access external APIs.
  Limited Usefulness of Private Subnets:

  Private subnets would only be able to communicate with other resources within the VPC.
  Key Takeaways
  Yes, cidr_block = "0.0.0.0/0" is correct for directing all outbound traffic from private subnets through the NAT Gateway.
  It does not expose private subnets to the internet because inbound traffic to private subnets must flow through the ALB or other configured mechanisms.
*/

  tags = {
    Name = "Private Route Table ${count.index + 1}"
  }
}

# Associate private route tables with the private subnet in the corresponding AZ.
resource "aws_route_table_association" "private" {
  count          = length(var.private_subnet_cidrs)
  subnet_id      = aws_subnet.private[count.index].id
  route_table_id = aws_route_table.private[count.index].id
}
/*
Why Is This Important?
Without associating the route table:

Subnets will use the VPC's main route table, which might not direct traffic through the NAT Gateway.
This can lead to connectivity issues for private subnet instances (e.g., no internet access).
*/

# We will also need to ensure public subnets are associated with route tables that point to the Internet Gateway.
# For that we'll go back and do that. 

/*
So the table associated to the nat gateway will understand to receive all traffic from the private subnet because of the cidr_block ? 
The route table associated with the NAT Gateway understands how to handle outbound traffic from the private subnet because of the cidr_block = "0.0.0.0/0" in its routing rules.

How the Route Table Works
Route Table Association:

Each private subnet is explicitly associated with a route table using aws_route_table_association.
Route Table Entry:

The cidr_block = "0.0.0.0/0" in the route table tells the subnet:
"For any traffic destined for external (non-VPC) addresses, send it to the NAT Gateway."
NAT Gateway as the Next Hop:

The route table specifies the NAT Gateway ID (nat_gateway_id = aws_nat_gateway.nat[count.index].id) as the next hop for all internet-bound traffic.

Traffic Flow
1. Outbound Traffic (Private Subnet → NAT Gateway → Internet):
From EC2 in Private Subnet:

The instance sends a packet destined for an external IP (e.g., 8.8.8.8).
The packet doesn't match any local or VPC CIDR in the route table.
It defaults to the rule with cidr_block = "0.0.0.0/0", which directs it to the NAT Gateway.
Through NAT Gateway:

The NAT Gateway forwards the traffic to the Internet Gateway, translating the private IP to the public Elastic IP attached to the NAT Gateway.
Response Traffic:

Responses from the internet (e.g., from 8.8.8.8) are routed back to the NAT Gateway, which translates the public IP back to the private IP and delivers the response to the private subnet.

2. Inbound Traffic (Internet → NAT Gateway):
NAT Gateway does not support inbound traffic.
Inbound traffic from the internet must go through other public-facing resources (e.g., an ALB in a public subnet).

Route Table Association:

By associating the route table with a private subnet, the subnet "inherits" these rules, ensuring all its outbound internet traffic flows through the NAT Gateway.
*/

/*
Traffic Flow
Public Subnets:
ALB and NAT Gateway use the Internet Gateway for internet access.
Private Subnets:
Outbound internet traffic (e.g., updates, external API calls) routes through the NAT Gateway.
Inbound traffic (e.g., database access) is restricted to specific security groups.
*/

/*
Why do we need 2 NAT Gateways?

Best Practices
AWS recommends having 1 NAT Gateway per AZ for high availability in multi-AZ setups. This ensures:

Resilient Connectivity:
Each private subnet has a NAT Gateway in the same AZ.
Cost Optimization:
Avoids cross-AZ charges for NAT Gateway usage.

Your Architecture with 2 NAT Gateways
Public Subnets:
Each public subnet hosts one NAT Gateway (1 per AZ).
Private Subnets:
Each private subnet routes traffic through the NAT Gateway in the same AZ.

Why Multiple NAT Gateways?
1. High Availability
In your setup with 2 Availability Zones (AZs), each private subnet resides in a different AZ.
A single NAT Gateway in one AZ cannot serve private subnets in another AZ if the first AZ becomes unavailable.
Having a NAT Gateway in each public subnet ensures that private subnets in both AZs can maintain internet connectivity even if one AZ goes down.
2. AZ-Level Fault Tolerance
AWS NAT Gateways are tied to specific AZs.
If the NAT Gateway's AZ experiences an outage, private subnets in that AZ would lose internet access unless there is a NAT Gateway in another AZ.
3. Reduced Latency
A NAT Gateway in the same AZ as the private subnet minimizes cross-AZ traffic.
Cross-AZ traffic incurs additional latency and costs, as AWS charges for data transfer across AZs.

Architecture Diagram:

Public Subnets: Host resources like the Application Load Balancer (ALB) and NAT Gateways.
Private Subnets: Host resources like EC2 instances (e.g., web servers) and RDS databases.

Traffic Flow:

Outbound Traffic from Private Subnets:

EC2 Instances in Private Subnets send outbound requests (e.g., software updates).
Traffic is routed to the NAT Gateway in the corresponding AZ's public subnet.
The NAT Gateway, associated with an Elastic IP (EIP), forwards the traffic to the Internet Gateway, enabling internet access.
Inbound Traffic to Public Subnets:

External users access the ALB via the Internet Gateway.
The ALB distributes traffic to EC2 Instances in the private subnets.

But you said that traffic can't be received back using the NAT gateway?!

You're absolutely correct: traffic from the internet to EC2 instances in private subnets cannot flow through a NAT Gateway. 
The NAT Gateway only facilitates outbound traffic from private subnets to the internet. Let’s clarify the roles of the NAT Gateway and Application Load Balancer (ALB) in this context:

Key Differences in Traffic Flow
1. NAT Gateway
Purpose: Enables outbound internet access for resources in private subnets.
Traffic Direction:
Outbound: Private subnet → NAT Gateway → Internet.
Inbound: Not supported (it does not handle incoming requests).
Use Case: Used for downloading software updates, communicating with APIs, or accessing external services.
2. Application Load Balancer (ALB)
Purpose: Distributes inbound traffic from the internet to EC2 instances in private subnets.
Traffic Direction:
Inbound: Internet → ALB (in public subnet) → EC2 instances (in private subnets).
Outbound (from EC2): Responses to the client return through the ALB.
Use Case: Exposes services hosted on private EC2 instances to the internet securely.
How Traffic Reaches Private EC2 Instances
Inbound Traffic (Internet → ALB → EC2):

The ALB, deployed in public subnets, listens for incoming traffic on HTTP/HTTPS.
After receiving traffic, the ALB forwards it to EC2 instances in private subnets based on its target group configuration.
No NAT Gateway is involved in this process.
Outbound Traffic (Private EC2 → Internet):

If EC2 instances in private subnets need to access the internet (e.g., for updates or API calls), they send traffic to the NAT Gateway.
The NAT Gateway facilitates the outbound traffic and returns responses from the internet.
Why ALB and NAT Gateway Complement Each Other
ALB: Handles inbound traffic from users to EC2 instances (web/app servers).
NAT Gateway: Handles outbound traffic from private resources to the internet (for backend operations).
Traffic Diagram
Here’s how traffic flows with both components in place:

Public Subnets:

Host the ALB and NAT Gateway.
ALB handles incoming traffic; NAT Gateway facilitates outbound traffic from private subnets.
Private Subnets:

Host EC2 instances (e.g., web servers or backend services).
Use NAT Gateway for outbound internet access.
Receive inbound traffic only through the ALB.

*/

/* 
Summary:

Benefits of This Setup
Security:

RDS is fully isolated in private subnets.
EC2 instances in public subnets handle public-facing requests and connect to RDS internally.
High Availability:

RDS instances span two private subnets in different AZs.
Scalability:

The architecture supports scaling EC2 instances or transitioning to auto-scaling.

For test we would connect to the EC2 instance and try connect to the RDS

*/

/*
1. Connection Between EC2 and RDS
The NAT Gateway is not required for the EC2 instances in public subnets to connect to the RDS instances in private subnets. Here's why:

EC2 to RDS Communication:
This happens internally within the VPC.
The EC2 instances in public subnets can directly communicate with RDS in private subnets as long as:
Security groups allow the connection.
Proper routing exists within the VPC.
Role of NAT Gateway
The NAT Gateway is only necessary if RDS itself (e.g., for patching) or EC2 instances in private subnets need outbound internet access.

2. How the Standby Instance Works
Purpose:
The standby instance is kept in sync with the primary instance using synchronous replication.
It automatically takes over if the primary instance fails (failover).
Key Points:
The standby instance is not directly accessible—it serves only as a failover.
During normal operations, all read and write traffic is routed to the primary instance.

Test EC2 to RDS Connectivity:
SSH into an EC2 instance in a public subnet and test the connection to the RDS primary instance.

*/

# ------------------------- ASG - Later - Everything is tied to EC2 - NEED to rebuild ------------------------- #

/*
module "asg" {
  source           = "./modules/asg"
  desired_capacity = 1                                  # Number of instances to start with
  min_size         = 1                                  # Minimum number of instances
  max_size         = 5                                  # Maximum number of instances
  subnet_ids       = aws_subnet.private[*].id                 # List of private subnet IDs
  ami              = "ami-0c02fb55956c7d316"            # AMI ID
  instance_type    = "t2.micro"                         # Instance type
  key_name         = "web-server-key"                   # Key pair for SSH access
  security_groups  = [aws_security_group.web_sg.id]     # Security group for the instances
  target_group_arns   = [module.alb.target_group_arn] # Pass ALB target group ARN as an input
}
*/